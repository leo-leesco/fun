val fix : all A. (A -> A) -> A -> A
type list_ :: Type -> Type -> Type = lam A. lam list. sum (unit) (A * list)
type list :: Type -> Type =
  lam A. fix ((lam A. lam list. sum (unit) (A * list)) A)
val nil :
  all A. (lam A1. fix ((lam A2. lam list1. sum (unit) (A2 * list1)) A1)) A
val cons :
  all A. A ->
    (lam A1. fix ((lam A2. lam list1. sum (unit) (A2 * list1)) A1)) A ->
    (lam A1. fix ((lam A2. lam list1. sum (unit) (A2 * list1)) A1)) A
val case_list :
  all A. all B.
    (lam A1. fix ((lam A2. lam list1. sum (unit) (A2 * list1)) A1)) A ->
    B ->
    ((A * (lam A1. fix ((lam A2. lam list1. sum (unit) (A2 * list1)) A1)) A) ->
       B) -> B
val map :
  all A. all B.
    ((A -> B) ->
       (lam A1. fix ((lam A2. lam list1. sum (unit) (A2 * list1)) A1)) A ->
       (lam A1. fix ((lam A2. lam list1. sum (unit) (A2 * list1)) A1)) B) ->
    (A -> B) ->
    (lam A1. fix ((lam A2. lam list1. sum (unit) (A2 * list1)) A1)) A ->
    (lam A1. fix ((lam A2. lam list1. sum (unit) (A2 * list1)) A1)) B
val map :
  all A. all B. (A -> B) ->
    (lam A1. fix ((lam A2. lam list1. sum (unit) (A2 * list1)) A1)) A ->
    (lam A1. fix ((lam A2. lam list1. sum (unit) (A2 * list1)) A1)) B
val map :
  all A. all B. (A -> B) ->
    (lam A1. fix ((lam A2. lam list1. sum (unit) (A2 * list1)) A1)) A ->
    (lam A1. fix ((lam A2. lam list1. sum (unit) (A2 * list1)) A1)) B
